#ifndef table_h_
#define table_h_

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cassert>
#include <algorithm>
#include <map>
#include <utility>
#include "movie.h"

class Table {
public:

	// initial size preference, resize_factor preference
	Table(size_t size_, float resize_factor) { // INITIAL CONSTRUCTOR
		m_table = std::vector<std::pair<size_t, 
		std::list<Movie*> > >(size_);
		m_f = resize_factor;
		m_size = 0;
	}

	const size_t& size() const { 
		return m_size;
	}

	void print_table() {
		std::cout << "Total Hashes: " << m_size << std::endl
		<< "Table Size: " << m_table.size() << std::endl; 
	}

	const std::list<Movie*>& query(std::string query) const { 
		size_t k = movie_hash(query);
		size_t i = k;
		// Linearly probe until a list with the matching key is found. 
		while (m_table[i % m_table.size()].first != k && 
			m_table[i % m_table.size()].second.size() != 0) { 
			i++;
		}
		return m_table[i % m_table.size()].second;
	}


	void insert(Movie* m) { // Insert calls combs and then calls insert. 
		std::vector<size_t> partial_hashes;
		std::string h = "";
		// Add the unadulterated hash which is not generated by combs(). 
		for (int q = 0; q < (m -> hashes).size(); q++) {
			h += (m -> hashes)[q];
		}
		partial_hashes.push_back(movie_hash(h));
		// populate partial_hashes<size_t> with all 63 other hashes.
		combs(m -> hashes, partial_hashes, 0);
		// insert all of the hashes into the table for the particular
		// movie pointer. 		
		for (int i = 0; i < partial_hashes.size(); i++) {
			insert(m, partial_hashes[i]);
		}
	}

	// int i = 0
	// partial_hashes.size() == 1
	// params<string> is movie.hashes
	void combs(std::vector<std::string> params, 
		std::vector<size_t>& partial_hashes, int i) {

		// starting at any index, apply this algorithm to
		// every subsequent index. 
		for (int j = i; j < params.size(); j++) {
			// save the variable we will replace. 
			std::string hold = params[j];
			params[j] = "?";
			std::string h = "";
			// concatenate string with added "?"
			for (int q = 0; q < params.size(); q++) {
				h += params[q];
			}

			// add to partial hashes
			partial_hashes.push_back(movie_hash(h));
			combs(params, partial_hashes, j + 1);
			// back track after recursive call and loop to attempt
			// next location. 
			params[j] = hold;
		}
	}

	// one insert call for every partial hash. 
	void insert(Movie* m, size_t partial_hash) {
		// resize as needed. 
		if ((float)m_size/((float)(m_table.size())) >= m_f) {
			resize(m_table.size() * 2); 
		}
		// find the first location that this movie can possibly
		// be assigned.
		size_t i = (partial_hash) % m_table.size();

		// if it is occupied by partial hashes with a different
		// key, linearly probe forwards until empty position or
		// position with matching key is found. 
		while (m_table[i].second.size() != 0 && 
			m_table[i].first != partial_hash) {
			i++;
			i %= m_table.size();
		}

		// if it is an empty location then increase m_size by one. 
		if (m_table[i].second.size() == 0) {
			m_size++;
		}

		// set the hash value for the location (potentially already set).
		// and add the movie pointer to the list for that partial query. 
		m_table[i].first = partial_hash;
		m_table[i].second.push_back(m);
	}

	void print_hash(const std::string& s) const {
		std::cout << movie_hash(s) << std::endl;
	}
	

	Table& operator=(const Table& n) {
		m_table = n.m_table;
		m_f = n.m_f;
		m_size = n.m_size;
		return *this;
	}

private:

	size_t movie_hash(const std::string& key) const {
		//  This implementation comes from 
		//  http://www.partow.net/programming/hashfunctions/
		//
		//  This is a general-purpose, very good hash function for strings.
		size_t hash = 1315423911;
		for(size_t i = 0; i < key.length(); i++) {
			hash ^= ((hash << 5) + (size_t)key[i] + (hash >> 2));
		}
		return hash;
	}




	// size_t movie_hash(const std::string& key) const {
	//     size_t hash = 1315423911;

	//     // My own hash funcion. 
	//     for (int c = 0; c < key.size(); c++) {
	//         hash = ((hash << 5) + hash) + key[c]; 
	//     }
	//     return hash;
	// }

	void resize(size_t new_size) {
		// Allocate new vector space with double size. 
		std::vector<std::pair<size_t, 
		std::list<Movie*> > > n_table(new_size);

		// iterate through entire current hash table. 
		for (size_t i = 0; i < m_table.size(); i++) {
			// if there is a non-empty collection of movie pointers. 
			if (m_table[i].second.size() != 0) {
				// rehash the entire collection as a group since they
				// all have the same key. 
				size_t k = (m_table[i].first) % new_size; 
				while (n_table[k].second.size() != 0 ) {
					k++;
					k %= new_size;
				}
				n_table[k] = m_table[i];
			}
		}

		// copy n_table to self object. 
		m_table = n_table;
	}


	// TABLE REPRESENTATION

	// vector of pairs of a key and a list of movie pointers. 
	std::vector<std::pair<size_t, 
	std::list<Movie*> > > m_table; 

	// resize factor and number of 
	// unique keys stored in hash table. 

	float m_f;
	size_t m_size;


};










#endif




// okie